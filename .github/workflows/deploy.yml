name: Deploy Backend to Elastic Beanstalk (Docker)

on:
  push:
    branches: [ main ]
  workflow_dispatch: {}

permissions:
  id-token: write      # necesario para OIDC
  contents: read       # necesario para checkout

env:
  AWS_REGION: ${{ secrets.AWS_REGION }}
  ECR_REPO_URI: ${{ secrets.ECR_REPO_URI }}
  EB_APP_NAME: ${{ secrets.EB_APP_NAME }}
  EB_ENV_NAME: ${{ secrets.EB_ENV_NAME }}
  EB_S3_BUCKET: ${{ secrets.EB_S3_BUCKET }}

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest

    env:
      # ðŸ”¹ Valores DUMMY solo para CI (tests)
      DB_HOST: localhost
      DB_PORT: 5432
      DB_NAME: test_db
      DB_USER: test_user
      DB_PASSWORD: test_password

      JWT_SECRET: test_jwt_secret
      SES_SENDER_EMAIL: test@example.com

      PUBLIC_BASE_URL: http://localhost:3000/
      AVATAR_BUCKET: dummy-avatar-bucket
      AVATAR_CDN_BASE: https://dummy-avatar-bucket.s3.us-east-2.amazonaws.com/
      AVATAR_PREFIX: avatars/

      COOKIE_DOMAIN: ""
      CROSS_SITE_COOKIES: "0"
      DAILY_TZ: UTC
      GENERATION_SECRET: dummy_generation_secret
      DISABLE_SCHEDULER: "1"   # asÃ­ no corre scheduler en CI

    steps:
      - name: Checkout
        uses: actions/checkout@v4

          # === CI: instalar deps y correr pytest antes del deploy ===
      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.12'

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt

      - name: Run backend tests (pytest)
        run: pytest app/tests


      - name: Configure AWS credentials (OIDC)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: arn:aws:iam::916205284452:role/GitHubActions-EB-Deploy
          aws-region: ${{ secrets.AWS_REGION }}

#      - name: Configure AWS credentials
#        uses: aws-actions/configure-aws-credentials@v4
#        with:
#          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
#          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
#          aws-region: ${{ secrets.AWS_REGION }}

      - name: Sanity check ECR URI vs Region (reject public ECR)
        shell: bash
        run: |
          set -euo pipefail
          echo "ECR_REPO_URI=$ECR_REPO_URI"
          echo "AWS_REGION=$AWS_REGION"

          if [[ "$ECR_REPO_URI" =~ ^public\.ecr\.aws ]]; then
            echo "âŒ ECR_REPO_URI apunta a ECR Public. Usa ECR privado: ACCOUNT_ID.dkr.ecr.${AWS_REGION}.amazonaws.com/REPO"
            exit 1
          fi

          HOST_PART=$(echo "$ECR_REPO_URI" | awk -F/ '{print $1}')
          EXPECTED_HOST_SUFFIX=".dkr.ecr.${AWS_REGION}.amazonaws.com"
          if [[ "$HOST_PART" != *"$EXPECTED_HOST_SUFFIX" ]]; then
            echo "âŒ La regiÃ³n del host en ECR_REPO_URI no coincide con AWS_REGION."
            echo "Host: $HOST_PART ; Esperado que termine en: $EXPECTED_HOST_SUFFIX"
            exit 1
          fi
          echo "âœ… Sanity check OK"

      - name: Login to Amazon ECR
        uses: aws-actions/amazon-ecr-login@v2

      - name: Define build vars
        id: vars
        shell: bash
        run: |
          set -euo pipefail
          IMAGE_TAG="sha-$(echo "$GITHUB_SHA" | cut -c1-7)-$(date +%Y%m%d%H%M%S)"
          BUNDLE_KEY="dockerrun-${GITHUB_RUN_ID}-${GITHUB_RUN_ATTEMPT}.zip"
          REPO_NAME="$(echo "$ECR_REPO_URI" | awk -F/ '{print $2}')"

          # Exportar a GITHUB_ENV
          {
            echo "IMAGE_TAG=$IMAGE_TAG"
            echo "BUNDLE_KEY=$BUNDLE_KEY"
            echo "REPO_NAME=$REPO_NAME"
          } >> "$GITHUB_ENV"

          # Logs informativos (ya definidas en este shell)
          echo "Resolved REPO_NAME=$REPO_NAME"
          echo "Resolved IMAGE_TAG=$IMAGE_TAG"

      - name: Build Docker image
        run: |
          docker build -t "$ECR_REPO_URI:$IMAGE_TAG" .

      - name: Push image to ECR
        run: |
          docker push "$ECR_REPO_URI:$IMAGE_TAG"

      - name: Verify image exists in ECR and capture digest
        id: verify
        shell: bash
        run: |
          set -euo pipefail
          DIGEST=$(aws ecr describe-images \
            --repository-name "$REPO_NAME" \
            --image-ids imageTag="$IMAGE_TAG" \
            --region "$AWS_REGION" \
            --query 'imageDetails[0].imageDigest' \
            --output text)
          if [[ "$DIGEST" == "None" || -z "$DIGEST" ]]; then
            echo "âŒ No se encontrÃ³ la imagen con tag $IMAGE_TAG en $REPO_NAME"
            exit 1
          fi
          echo "DIGEST=$DIGEST" >> "$GITHUB_ENV"
          echo "âœ… Imagen verificada en ECR. Digest: $DIGEST"

      - name: Create Dockerrun.aws.json (single container)
        shell: bash
        run: |
          cat > Dockerrun.aws.json <<EOF
          {
            "AWSEBDockerrunVersion": "1",
            "Image": {
              "Name": "${ECR_REPO_URI}:${IMAGE_TAG}",
              "Update": "true"
            },
            "Ports": [
              { "ContainerPort": "80" }
            ],
            "Logging": "/var/log/app"
          }
          EOF
          echo "==== Dockerrun.aws.json ===="
          cat Dockerrun.aws.json

      - name: Zip bundle
        run: zip -r "$BUNDLE_KEY" Dockerrun.aws.json

      - name: Upload bundle to S3
        run: aws s3 cp "$BUNDLE_KEY" "s3://$EB_S3_BUCKET/$BUNDLE_KEY"

      - name: Create EB Application Version
        run: |
          aws elasticbeanstalk create-application-version \
            --application-name "$EB_APP_NAME" \
            --version-label "$IMAGE_TAG" \
            --description "Git:${GITHUB_SHA::7} Digest:${DIGEST} Repo:${ECR_REPO_URI}" \
            --source-bundle S3Bucket="$EB_S3_BUCKET",S3Key="$BUNDLE_KEY" \
            --process

      - name: Update EB Environment
        run: |
          aws elasticbeanstalk update-environment \
            --environment-name "$EB_ENV_NAME" \
            --version-label "$IMAGE_TAG"

      - name: Monitor EB Events (wait for Ready+OK/Green)
        shell: bash
        run: |
          echo "Esperando a que el ambiente alcance estado Ready + (Green/Ok)..."
          end=$((SECONDS+1800))  # 30 min
          while [ $SECONDS -lt $end ]; do
            aws elasticbeanstalk describe-events \
              --environment-name "$EB_ENV_NAME" \
              --region "$AWS_REGION" \
              --max-items 5 \
              --output table || true

            read -r ENV_STATUS HEALTH HEALTH_STATUS VERSION <<<"$(aws elasticbeanstalk describe-environments \
              --environment-names "$EB_ENV_NAME" \
              --region "$AWS_REGION" \
              --query 'Environments[0].[Status,Health,HealthStatus,VersionLabel]' \
              --output text)"

            echo "Estado actual: Status=$ENV_STATUS | Health=$HEALTH | HealthStatus=$HEALTH_STATUS | Version=$VERSION"

            if [[ "$ENV_STATUS" == "Ready" && ( "$HEALTH" == "Green" || "$HEALTH_STATUS" == "Ok" ) ]]; then
              echo "âœ… Ambiente listo: Ready + ${HEALTH}/${HEALTH_STATUS}"
              exit 0
            fi
            sleep 30
          done
          echo "â° Timeout esperando Ready + (Green/Ok)"
          exit 1
