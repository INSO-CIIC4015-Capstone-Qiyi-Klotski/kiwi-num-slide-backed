name: Deploy Backend to Elastic Beanstalk (Docker)

on:
  push:
    branches: [ main ]
  workflow_dispatch: {}

env:
  AWS_REGION: ${{ secrets.AWS_REGION }}
  ECR_REPO_URI: ${{ secrets.ECR_REPO_URI }}
  EB_APP_NAME: ${{ secrets.EB_APP_NAME }}
  EB_ENV_NAME: ${{ secrets.EB_ENV_NAME }}
  EB_S3_BUCKET: ${{ secrets.EB_S3_BUCKET }}

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest

    permissions:
      id-token: write      # necesario para OIDC
      contents: read       # necesario para checkout

#    env:
#      # Valores DUMMY solo para CI (tests)
#      DB_HOST: localhost
#      DB_PORT: 5432
#      DB_NAME: test_db
#      DB_USER: test_user
#      DB_PASSWORD: test_password
#
#      JWT_SECRET: test_jwt_secret
#      SES_SENDER_EMAIL: test@example.com
#
#      PUBLIC_BASE_URL: http://localhost:3000/
#      AVATAR_BUCKET: dummy-avatar-bucket
#      AVATAR_CDN_BASE: https://dummy-avatar-bucket.s3.us-east-2.amazonaws.com/
#      AVATAR_PREFIX: avatars/
#
#      COOKIE_DOMAIN: ""
#      CROSS_SITE_COOKIES: "0"
#      DAILY_TZ: UTC
#      GENERATION_SECRET: dummy_generation_secret
#      DISABLE_SCHEDULER: "1"   # asÃ­ no corre scheduler en CI

    steps:
      - name: Checkout
        uses: actions/checkout@v4

          # === CI: instalar deps y correr pytest antes del deploy ===
#      - name: Setup Python
#        uses: actions/setup-python@v5
#        with:
#          python-version: '3.12'
#
#      - name: Install dependencies
#        run: |
#          python -m pip install --upgrade pip
#          pip install -r requirements.txt

#      - name: Run backend tests (pytest)
#        run: pytest app/tests

      - name: Precheck infra via Terraform Cloud (latest run)
        shell: bash
        env:
          TF_API_TOKEN: ${{ secrets.TF_API_TOKEN }}
          TF_CLOUD_ORGANIZATION: ${{ secrets.TF_CLOUD_ORGANIZATION }}
          TF_WORKSPACE: ${{ secrets.TF_WORKSPACE }}
        run: |
          set -euo pipefail

          echo "ðŸ” Precheck: Terraform Cloud latest run for $TF_CLOUD_ORGANIZATION/$TF_WORKSPACE"

          # 1) Workspace info (get ID)
          ws_json="$(curl -sS \
            -H "Authorization: Bearer $TF_API_TOKEN" \
            -H "Content-Type: application/vnd.api+json" \
            "https://app.terraform.io/api/v2/organizations/$TF_CLOUD_ORGANIZATION/workspaces/$TF_WORKSPACE")"

          ws_id="$(echo "$ws_json" | jq -r '.data.id')"
          if [[ -z "$ws_id" || "$ws_id" == "null" ]]; then
            echo "::error::Workspace not found."
            exit 1
          fi

          # 2) Latest run
          runs_json="$(curl -sS \
            -H "Authorization: Bearer $TF_API_TOKEN" \
            -H "Content-Type: application/vnd.api+json" \
            "https://app.terraform.io/api/v2/workspaces/$ws_id/runs?page[size]=1")"

          status="$(echo "$runs_json" | jq -r '.data[0].attributes.status')"
          is_destroy="$(echo "$runs_json" | jq -r '.data[0].attributes."is-destroy"')"
          msg="$(echo "$runs_json" | jq -r '.data[0].attributes.message // ""')"

          echo "Latest run: status=$status | is_destroy=$is_destroy"
          echo "Message: $msg"

          # If last run was a destroy that got applied -> infra is down
          if [[ "$is_destroy" == "true" && "$status" == "applied" ]]; then
            echo "::error::Infra appears DOWN (latest run is destroy/applied)."
            exit 1
          fi

          # If last run applied and not destroy -> infra up
          if [[ "$is_destroy" == "false" && "$status" == "applied" ]]; then
            echo "âœ… Infra appears UP (latest run applied)."
            exit 0
          fi

          # Otherwise: uncertain / in-progress / errored -> block deploy (or decide to skip)
          echo "::error::Infra status unclear (latest run status=$status). Aborting deploy."
          exit 1

      - name: Debug OIDC claims (safe)
        shell: bash
        run: |
          set -euo pipefail
          resp="$(curl -sSL \
            -H "Authorization: bearer $ACTIONS_ID_TOKEN_REQUEST_TOKEN" \
            "${ACTIONS_ID_TOKEN_REQUEST_URL}&audience=sts.amazonaws.com")"
          token="$(echo "$resp" | jq -r '.value')"
          payload="$(echo "$token" | cut -d. -f2 | tr '_-' '/+' | base64 -d 2>/dev/null || true)"
          echo "$payload" | jq '{sub, job_workflow_ref, aud, repository, ref}'

      - name: Configure AWS credentials (OIDC)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: arn:aws:iam::916205284452:role/GitHubActions-EB-Deploy
          aws-region: ${{ secrets.AWS_REGION }}

#      - name: Configure AWS credentials
#        uses: aws-actions/configure-aws-credentials@v4
#        with:
#          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
#          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
#          aws-region: ${{ secrets.AWS_REGION }}

      - name: Sanity check ECR URI vs Region (reject public ECR)
        shell: bash
        run: |
          set -euo pipefail
          echo "ECR_REPO_URI=$ECR_REPO_URI"
          echo "AWS_REGION=$AWS_REGION"

          if [[ "$ECR_REPO_URI" =~ ^public\.ecr\.aws ]]; then
            echo "âŒ ECR_REPO_URI apunta a ECR Public. Usa ECR privado: ACCOUNT_ID.dkr.ecr.${AWS_REGION}.amazonaws.com/REPO"
            exit 1
          fi

          HOST_PART=$(echo "$ECR_REPO_URI" | awk -F/ '{print $1}')
          EXPECTED_HOST_SUFFIX=".dkr.ecr.${AWS_REGION}.amazonaws.com"
          if [[ "$HOST_PART" != *"$EXPECTED_HOST_SUFFIX" ]]; then
            echo "âŒ La regiÃ³n del host en ECR_REPO_URI no coincide con AWS_REGION."
            echo "Host: $HOST_PART ; Esperado que termine en: $EXPECTED_HOST_SUFFIX"
            exit 1
          fi
          echo "âœ… Sanity check OK"

      - name: Login to Amazon ECR
        uses: aws-actions/amazon-ecr-login@v2

      - name: Define build vars
        id: vars
        shell: bash
        run: |
          set -euo pipefail
          IMAGE_TAG="sha-$(echo "$GITHUB_SHA" | cut -c1-7)-$(date +%Y%m%d%H%M%S)"
          BUNDLE_KEY="dockerrun-${GITHUB_RUN_ID}-${GITHUB_RUN_ATTEMPT}.zip"
          REPO_NAME="$(echo "$ECR_REPO_URI" | awk -F/ '{print $2}')"

          # Exportar a GITHUB_ENV
          {
            echo "IMAGE_TAG=$IMAGE_TAG"
            echo "BUNDLE_KEY=$BUNDLE_KEY"
            echo "REPO_NAME=$REPO_NAME"
          } >> "$GITHUB_ENV"

          # Logs informativos (ya definidas en este shell)
          echo "Resolved REPO_NAME=$REPO_NAME"
          echo "Resolved IMAGE_TAG=$IMAGE_TAG"

      - name: Build Docker image
        run: |
          docker build -t "$ECR_REPO_URI:$IMAGE_TAG" .

      - name: Push image to ECR
        run: |
          docker push "$ECR_REPO_URI:$IMAGE_TAG"

      - name: Verify image exists in ECR and capture digest
        id: verify
        shell: bash
        run: |
          set -euo pipefail
          DIGEST=$(aws ecr describe-images \
            --repository-name "$REPO_NAME" \
            --image-ids imageTag="$IMAGE_TAG" \
            --region "$AWS_REGION" \
            --query 'imageDetails[0].imageDigest' \
            --output text)
          if [[ "$DIGEST" == "None" || -z "$DIGEST" ]]; then
            echo "âŒ No se encontrÃ³ la imagen con tag $IMAGE_TAG en $REPO_NAME"
            exit 1
          fi
          echo "DIGEST=$DIGEST" >> "$GITHUB_ENV"
          echo "âœ… Imagen verificada en ECR. Digest: $DIGEST"

      - name: Create Dockerrun.aws.json (single container)
        shell: bash
        run: |
          cat > Dockerrun.aws.json <<EOF
          {
            "AWSEBDockerrunVersion": "1",
            "Image": {
              "Name": "${ECR_REPO_URI}:${IMAGE_TAG}",
              "Update": "true"
            },
            "Ports": [
              { "ContainerPort": "80" }
            ],
            "Logging": "/var/log/app"
          }
          EOF
          echo "==== Dockerrun.aws.json ===="
          cat Dockerrun.aws.json

      - name: Zip bundle
        run: zip -r "$BUNDLE_KEY" Dockerrun.aws.json

      - name: Upload bundle to S3
        run: aws s3 cp "$BUNDLE_KEY" "s3://$EB_S3_BUCKET/$BUNDLE_KEY"

      - name: Create EB Application Version
        run: |
          aws elasticbeanstalk create-application-version \
            --application-name "$EB_APP_NAME" \
            --version-label "$IMAGE_TAG" \
            --description "Git:${GITHUB_SHA::7} Digest:${DIGEST} Repo:${ECR_REPO_URI}" \
            --source-bundle S3Bucket="$EB_S3_BUCKET",S3Key="$BUNDLE_KEY" \
            --process

      - name: Update EB Environment
        run: |
          aws elasticbeanstalk update-environment \
            --environment-name "$EB_ENV_NAME" \
            --version-label "$IMAGE_TAG"

      - name: Monitor EB Events (wait for Ready+OK/Green)
        shell: bash
        run: |
          echo "Esperando a que el ambiente alcance estado Ready + (Green/Ok)..."
          end=$((SECONDS+1800))  # 30 min
          while [ $SECONDS -lt $end ]; do
            aws elasticbeanstalk describe-events \
              --environment-name "$EB_ENV_NAME" \
              --region "$AWS_REGION" \
              --max-items 5 \
              --output table || true

            read -r ENV_STATUS HEALTH HEALTH_STATUS VERSION <<<"$(aws elasticbeanstalk describe-environments \
              --environment-names "$EB_ENV_NAME" \
              --region "$AWS_REGION" \
              --query 'Environments[0].[Status,Health,HealthStatus,VersionLabel]' \
              --output text)"

            echo "Estado actual: Status=$ENV_STATUS | Health=$HEALTH | HealthStatus=$HEALTH_STATUS | Version=$VERSION"

            if [[ "$ENV_STATUS" == "Ready" && ( "$HEALTH" == "Green" || "$HEALTH_STATUS" == "Ok" ) ]]; then
              echo "âœ… Ambiente listo: Ready + ${HEALTH}/${HEALTH_STATUS}"
              exit 0
            fi
            sleep 30
          done
          echo "â° Timeout esperando Ready + (Green/Ok)"
          exit 1
